name: 'Generate Combined Deployment Matrices'
description: 'Parses multiple deployment config files and generates combined matrices with dynamic secret processing'
inputs:
  resource_paths:
    description: 'Comma-separated paths to resources (e.g., cloud-formation/rcc/a-crs-spa,cloud-formation/rcc/another-resource)'
    required: true
  specific_environment:
    description: 'Specific environment to deploy (empty for all configured)'
    required: false
    default: ''
  process_secrets:
    description: 'Process secrets in parameters (true/false)'
    required: false
    default: 'true'

outputs:
  dev_matrix:
    description: 'Matrix for DEV deployments'
    value: ${{ steps.generate-matrices.outputs.dev_matrix }}
  int_matrix:
    description: 'Matrix for INT deployments'
    value: ${{ steps.generate-matrices.outputs.int_matrix }}
  prod_matrix:
    description: 'Matrix for PROD deployments'
    value: ${{ steps.generate-matrices.outputs.prod_matrix }}

runs:
  using: "composite"
  steps:
    - name: Install yq
      shell: bash
      run: |
        if ! command -v yq &> /dev/null; then
          echo "Installing yq..."
          VERSION=v4.30.8
          BINARY=yq_linux_amd64
          wget https://github.com/mikefarah/yq/releases/download/${VERSION}/${BINARY}.tar.gz -O - | \
            tar xz
          chmod +x ${BINARY}
          sudo mv ${BINARY} /usr/bin/yq || mkdir -p $HOME/bin && mv ${BINARY} $HOME/bin/yq && echo "$HOME/bin" >> $GITHUB_PATH
        fi

    - name: Generate deployment matrices
      id: generate-matrices
      shell: bash
      run: |
        # Initialize empty arrays for matrix items
        DEV_MATRIX_ITEMS=()
        INT_MATRIX_ITEMS=()
        PROD_MATRIX_ITEMS=()
        
        # Function to extract secret names from a string
        extract_secret_names() {
          local content="$1"
          local temp_file="/tmp/secret-extract-$RANDOM.txt"
          local SECRET_PATTERN='\${{[[:space:]]*secrets\.[A-Za-z0-9_-]*[[:space:]]*}}'
          
          # Extract everything that looks like ${{ secrets.SOMETHING }}
          echo "$content" | grep -o "$SECRET_PATTERN" | sort -u > "$temp_file"
          
          # Extract just the secret names
          if [[ -s "$temp_file" ]]; then
            cat "$temp_file" | sed -E 's/.*secrets\.([A-Za-z0-9_-]*).*}}/\1/g'
          fi
          
          rm -f "$temp_file"
        }
        
        # Function to process secrets in a JSON string
        process_secrets_in_json() {
          local json_str="$1"
          
          # Only process if feature enabled
          if [[ "${{ inputs.process_secrets }}" != "true" ]]; then
            echo "$json_str"
            return
          fi
          
          # Check if the content contains any secrets pattern
          if [[ "$json_str" == *'${{' && "$json_str" == *'secrets.' && "$json_str" == *'}}' ]]; then
            echo "Found secrets pattern in parameters, processing..."
            
            # Extract secret names
            local secret_names=$(extract_secret_names "$json_str")
            
            # Loop through each secret name
            for secret_name in $secret_names; do
              # Access the secret value from environment variables
              # This is the key part - the environment variables should be available directly
              local secret_value="${!secret_name}"
              
              if [[ -n "$secret_value" ]]; then
                echo "Processing secret: $secret_name"
                # Replace all occurrences of the secret reference with its value
                # We use a safe pattern that should work in YAML
                local REPLACE_PATTERN='\${{[[:space:]]*secrets\.'$secret_name'[[:space:]]*}}'
                json_str=$(echo "$json_str" | sed "s|$REPLACE_PATTERN|$secret_value|g")
              else
                echo "Warning: Secret $secret_name not available in environment"
              fi
            done
            
            # Process parameter-file if present
            local pf=$(echo "$json_str" | jq -r '.["parameter-file"] // ""')
            
            if [[ -n "$pf" && "$pf" != "null" && -f "$pf" ]]; then
              echo "Processing secrets in parameter file: $pf"
              local temp_dir="/tmp/matrix-params"
              mkdir -p "$temp_dir"
              local proc_file="$temp_dir/$(basename "$pf")"
              
              # Read the file content
              local file_content=$(cat "$pf")
              
              # Check if file contains secrets
              if [[ "$file_content" == *'${{' && "$file_content" == *'secrets.' && "$file_content" == *'}}' ]]; then
                # Extract secret names from file
                local file_secret_names=$(extract_secret_names "$file_content")
                
                # Process each secret
                for secret_name in $file_secret_names; do
                  local secret_value="${!secret_name}"
                  
                  if [[ -n "$secret_value" ]]; then
                    echo "Processing secret in file: $secret_name"
                    local FILE_REPLACE_PATTERN='\${{[[:space:]]*secrets\.'$secret_name'[[:space:]]*}}'
                    file_content=$(echo "$file_content" | sed "s|$FILE_REPLACE_PATTERN|$secret_value|g")
                  else
                    echo "Warning: Secret $secret_name not available for parameter file"
                  fi
                done
                
                # Write processed content to new file
                echo "$file_content" > "$proc_file"
                
                # Update the parameter-file path in the JSON
                json_str=$(echo "$json_str" | jq --arg path "$proc_file" '.["parameter-file"]=$path')
              else
                # No secrets in file, just use original
                echo "No secrets found in parameter file"
                cp "$pf" "$proc_file"
                json_str=$(echo "$json_str" | jq --arg path "$proc_file" '.["parameter-file"]=$path')
              fi
            fi
          fi
          
          echo "$json_str"
        }
        
        # Split input resource paths by comma
        IFS=',' read -ra RESOURCE_PATHS <<< "${{ inputs.resource_paths }}"
        
        # Process each resource path
        for RESOURCE_PATH in "${RESOURCE_PATHS[@]}"; do
          echo "Processing resource path: $RESOURCE_PATH"
          
          # Try both YAML and YML extensions
          CONFIG_PATH="${RESOURCE_PATH}/deployment-config.yaml"
          if [[ ! -f "$CONFIG_PATH" ]]; then
            CONFIG_PATH="${RESOURCE_PATH}/deployment-config.yml"
            if [[ ! -f "$CONFIG_PATH" ]]; then
              echo "::warning::Configuration file not found for $RESOURCE_PATH"
              continue
            fi
          fi
          
          # Read YAML config file and convert to JSON for processing
          echo "Reading YAML configuration from $CONFIG_PATH"
          CONFIG_CONTENT=$(yq -o=json eval . "$CONFIG_PATH")
          
          # Extract app and resource from path
          APP=$(dirname "$RESOURCE_PATH")
          RESOURCE=$(basename "$RESOURCE_PATH")
          
          echo "Using APP=$APP and RESOURCE=$RESOURCE"
          
          # Validate JSON structure
          echo "$CONFIG_CONTENT" | jq . > /dev/null 2>&1
          if [[ $? -ne 0 ]]; then
            echo "::warning::Invalid YAML structure in $CONFIG_PATH"
            continue
          fi
          
          # Get environments list
          ENVIRONMENTS=$(echo "$CONFIG_CONTENT" | jq -r '.deployments[0].environments[]' 2>/dev/null || echo "")
          if [[ -z "$ENVIRONMENTS" ]]; then
            echo "::warning::No environments found in $CONFIG_PATH"
            continue
          fi
          
          echo "Found environments: $ENVIRONMENTS"
          
          # Filter by specific environment if provided
          if [[ "${{ inputs.specific_environment }}" != "" ]]; then
            if echo "$ENVIRONMENTS" | grep -q "${{ inputs.specific_environment }}"; then
              ENVIRONMENTS="${{ inputs.specific_environment }}"
            else
              echo "::warning::Specified environment not found in $CONFIG_PATH"
              continue
            fi
          fi
          
          # Process each environment for this resource
          for ENV in $ENVIRONMENTS; do
            echo "Processing environment: $ENV for $RESOURCE_PATH"
            
            # Extract parameters as compact JSON (no newlines)
            PARAMS=$(echo "$CONFIG_CONTENT" | jq -c --arg env "$ENV" '.deployments[0].parameters[$env]')
            RUNNER=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].runners[$env]')
            GH_ENV=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].github_environments[$env]')
            AWS_REGION=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].aws_regions[$env]')
            AWS_ROLE_SECRET=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].aws_role_secrets[$env] // "AWS_ROLE_TO_ASSUME"')
            CFN_ROLE_SECRET=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].cfn_role_secrets[$env] // "CFN_ROLE_ARN"')
            IAM_ROLE_SECRET=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].iam_execution_role_secrets[$env] // "IAM_EXECUTION_ROLE_ARN"')
            VARS_CONFIG=$(echo "$CONFIG_CONTENT" | jq -c --arg env "$ENV" '.deployments[0].github_vars[$env] // {}')
            
            # Skip if any required field is empty
            if [[ -z "$PARAMS" || "$PARAMS" == "null" || -z "$RUNNER" || "$RUNNER" == "null" || 
                  -z "$GH_ENV" || "$GH_ENV" == "null" || -z "$AWS_REGION" || "$AWS_REGION" == "null" ]]; then
              echo "::warning::Missing required configuration for $RESOURCE_PATH in $ENV environment"
              continue
            fi
            
            # Process secrets in parameters if enabled
            PROCESSED_PARAMS=$(process_secrets_in_json "$PARAMS")
            
            # Create matrix item (all on one line)
            MATRIX_ITEM="{\"application\":\"$APP\",\"resource\":\"$RESOURCE\",\"environment\":\"$ENV\",\"runner\":\"$RUNNER\",\"github_environment\":\"$GH_ENV\",\"aws_region\":\"$AWS_REGION\",\"aws_role_secret\":\"$AWS_ROLE_SECRET\",\"cfn_role_secret\":\"$CFN_ROLE_SECRET\",\"iam_role_secret\":\"$IAM_ROLE_SECRET\",\"github_vars\":$VARS_CONFIG,\"parameters\":$PROCESSED_PARAMS}"
            
            # Add to appropriate matrix based on environment
            if [[ "$ENV" == "dev" ]]; then
              DEV_MATRIX_ITEMS+=("$MATRIX_ITEM")
            elif [[ "$ENV" == "int" ]]; then
              INT_MATRIX_ITEMS+=("$MATRIX_ITEM")
            elif [[ "$ENV" == "prod" ]]; then
              PROD_MATRIX_ITEMS+=("$MATRIX_ITEM")
            fi
          done
        done
        
        # Construct environment-specific matrices
        if [ ${#DEV_MATRIX_ITEMS[@]} -eq 0 ]; then
          DEV_MATRIX_JSON="{\"include\":[]}"
        else
          DEV_MATRIX_JSON="{\"include\":[$(IFS=,; echo "${DEV_MATRIX_ITEMS[*]}")]}";
        fi
        
        if [ ${#INT_MATRIX_ITEMS[@]} -eq 0 ]; then
          INT_MATRIX_JSON="{\"include\":[]}"
        else
          INT_MATRIX_JSON="{\"include\":[$(IFS=,; echo "${INT_MATRIX_ITEMS[*]}")]}";
        fi
        
        if [ ${#PROD_MATRIX_ITEMS[@]} -eq 0 ]; then
          PROD_MATRIX_JSON="{\"include\":[]}"
        else
          PROD_MATRIX_JSON="{\"include\":[$(IFS=,; echo "${PROD_MATRIX_ITEMS[*]}")]}";
        fi
        
        # Verify JSON is valid
        echo "$DEV_MATRIX_JSON" | jq . > /dev/null 2>&1
        echo "$INT_MATRIX_JSON" | jq . > /dev/null 2>&1
        echo "$PROD_MATRIX_JSON" | jq . > /dev/null 2>&1
        
        # Write matrices to outputs
        echo "dev_matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$DEV_MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "int_matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$INT_MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "prod_matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$PROD_MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT