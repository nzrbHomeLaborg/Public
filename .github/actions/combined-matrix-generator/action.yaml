name: 'Generate Combined Deployment Matrices'
description: 'Parses multiple deployment config files and generates combined matrices with secret processing'
inputs:
  resource_paths:
    description: 'Comma-separated paths to resources (e.g., cloud-formation/rcc/a-crs-spa,cloud-formation/rcc/another-resource)'
    required: true
  specific_environment:
    description: 'Specific environment to deploy (empty for all configured)'
    required: false
    default: ''
  process_secrets:
    description: 'Process secrets in parameters (true/false)'
    required: false
    default: 'true'

outputs:
  dev_matrix:
    description: 'Matrix for DEV deployments'
    value: ${{ steps.generate-matrices.outputs.dev_matrix }}
  int_matrix:
    description: 'Matrix for INT deployments'
    value: ${{ steps.generate-matrices.outputs.int_matrix }}
  prod_matrix:
    description: 'Matrix for PROD deployments'
    value: ${{ steps.generate-matrices.outputs.prod_matrix }}

runs:
  using: "composite"
  steps:
    - name: Install yq
      shell: bash
      run: |
        if ! command -v yq &> /dev/null; then
          echo "Installing yq..."
          VERSION=v4.30.8
          BINARY=yq_linux_amd64
          wget https://github.com/mikefarah/yq/releases/download/${VERSION}/${BINARY}.tar.gz -O - | \
            tar xz
          chmod +x ${BINARY}
          sudo mv ${BINARY} /usr/bin/yq || mkdir -p $HOME/bin && mv ${BINARY} $HOME/bin/yq && echo "$HOME/bin" >> $GITHUB_PATH
        fi

    - name: Generate deployment matrices
      id: generate-matrices
      shell: bash
      run: |
        # Initialize empty arrays for matrix items
        DEV_MATRIX_ITEMS=()
        INT_MATRIX_ITEMS=()
        PROD_MATRIX_ITEMS=()
        
        # Process secrets in a string - replace any ${{ secrets.X }} with actual value
        process_secrets_string() {
          local str="$1"
          local modified_str="$str"
          
          # Only process if feature enabled and string contains the secrets keyword
          if [[ "${{ inputs.process_secrets }}" != "true" || "$str" != *"secrets."* ]]; then
            echo "$str"
            return
          fi
          
          # Extract potential secret references
          local secrets_list
          secrets_list=$(echo "$str" | grep -o '\${{.*secrets\.[^}]*}}' || echo "")
          
          # Process each secret reference
          if [[ -n "$secrets_list" ]]; then
            echo "Found secrets to process..."
            while IFS= read -r secret_ref; do
              # Extract just the secret name
              local secret_name
              secret_name=$(echo "$secret_ref" | sed -E 's/.*secrets\.([A-Za-z0-9_-]*).*/\1/')
              
              # Get the value from environment variables
              if [[ -n "$secret_name" ]]; then
                local secret_value="${!secret_name}"
                if [[ -n "$secret_value" ]]; then
                  echo "Replacing secret: $secret_name"
                  # Replace in the string (using | as delimiter to avoid issues with / in paths)
                  modified_str=$(echo "$modified_str" | sed "s|$secret_ref|$secret_value|g")
                else
                  echo "Warning: Secret $secret_name not available in environment"
                fi
              fi
            done <<< "$secrets_list"
          fi
          
          echo "$modified_str"
        }
        
        # Process secrets in a JSON object
        process_secrets_in_json() {
          local json_str="$1"
          
          # Only process if feature enabled
          if [[ "${{ inputs.process_secrets }}" != "true" || "$json_str" != *"secrets."* ]]; then
            echo "$json_str"
            return
          fi
          
          echo "Processing secrets in parameters..."
          
          # Process parameter-file if present
          local pf=$(echo "$json_str" | jq -r '.["parameter-file"] // ""')
          if [[ -n "$pf" && "$pf" != "null" && -f "$pf" ]]; then
            echo "Processing parameter file: $pf"
            local temp_dir="/tmp/matrix-params"
            mkdir -p "$temp_dir"
            local proc_file="$temp_dir/$(basename "$pf")"
            
            # Process the file content
            local file_content=$(cat "$pf")
            local processed_content
            processed_content=$(process_secrets_string "$file_content")
            
            # Only create new file if content was modified
            if [[ "$file_content" != "$processed_content" ]]; then
              echo "$processed_content" > "$proc_file"
              echo "Created processed parameter file: $proc_file"
              # Update the path in JSON
              json_str=$(echo "$json_str" | jq --arg path "$proc_file" '.["parameter-file"]=$path')
            else
              echo "No changes needed in parameter file"
            fi
          fi
          
          # Process inline-parameters if present
          if echo "$json_str" | jq -e '.["inline-parameters"]' >/dev/null 2>&1; then
            echo "Processing inline-parameters..."
            
            # Check if it's an array or object
            local inline_type
            inline_type=$(echo "$json_str" | jq -r 'if .["inline-parameters"] | type == "array" then "array" else "object" end')
            
            if [[ "$inline_type" == "array" ]]; then
              # Handle array format (with ParameterKey/ParameterValue)
              local item_count
              item_count=$(echo "$json_str" | jq '.["inline-parameters"] | length')
              
              # Process each item
              for ((i=0; i<item_count; i++)); do
                local param_value
                param_value=$(echo "$json_str" | jq -r --argjson idx "$i" '.["inline-parameters"][$idx].ParameterValue')
                
                # Only process string values that contain secrets
                if [[ -n "$param_value" && "$param_value" == *"secrets."* ]]; then
                  local processed_value
                  processed_value=$(process_secrets_string "$param_value")
                  
                  # Update the value if changed
                  if [[ "$param_value" != "$processed_value" ]]; then
                    json_str=$(echo "$json_str" | jq --argjson idx "$i" --arg val "$processed_value" '.["inline-parameters"][$idx].ParameterValue=$val')
                  fi
                fi
              done
            else
              # Handle object format (key/value pairs)
              local keys
              keys=$(echo "$json_str" | jq -r '.["inline-parameters"] | keys[]')
              
              # Process each key
              for key in $keys; do
                local value
                value=$(echo "$json_str" | jq -r --arg k "$key" '.["inline-parameters"][$k]')
                
                # Only process string values that contain secrets
                if [[ -n "$value" && "$value" == *"secrets."* ]]; then
                  local processed_value
                  processed_value=$(process_secrets_string "$value")
                  
                  # Update the value if changed
                  if [[ "$value" != "$processed_value" ]]; then
                    json_str=$(echo "$json_str" | jq --arg k "$key" --arg val "$processed_value" '.["inline-parameters"][$k]=$val')
                  fi
                fi
              done
            fi
          fi
          
          echo "$json_str"
        }
        
        # Split input resource paths by comma
        IFS=',' read -ra RESOURCE_PATHS <<< "${{ inputs.resource_paths }}"
        
        # Process each resource path
        for RESOURCE_PATH in "${RESOURCE_PATHS[@]}"; do
          echo "Processing resource path: $RESOURCE_PATH"
          
          # Try both YAML and YML extensions
          CONFIG_PATH="${RESOURCE_PATH}/deployment-config.yaml"
          if [[ ! -f "$CONFIG_PATH" ]]; then
            CONFIG_PATH="${RESOURCE_PATH}/deployment-config.yml"
            if [[ ! -f "$CONFIG_PATH" ]]; then
              echo "::warning::Configuration file not found for $RESOURCE_PATH"
              continue
            fi
          fi
          
          # Read YAML config file and convert to JSON for processing
          echo "Reading YAML configuration from $CONFIG_PATH"
          CONFIG_CONTENT=$(yq -o=json eval . "$CONFIG_PATH")
          
          # Extract app and resource from path
          APP=$(dirname "$RESOURCE_PATH")
          RESOURCE=$(basename "$RESOURCE_PATH")
          
          echo "Using APP=$APP and RESOURCE=$RESOURCE"
          
          # Validate JSON structure
          echo "$CONFIG_CONTENT" | jq . > /dev/null 2>&1
          if [[ $? -ne 0 ]]; then
            echo "::warning::Invalid YAML structure in $CONFIG_PATH"
            continue
          fi
          
          # Get environments list
          ENVIRONMENTS=$(echo "$CONFIG_CONTENT" | jq -r '.deployments[0].environments[]' 2>/dev/null || echo "")
          if [[ -z "$ENVIRONMENTS" ]]; then
            echo "::warning::No environments found in $CONFIG_PATH"
            continue
          fi
          
          echo "Found environments: $ENVIRONMENTS"
          
          # Filter by specific environment if provided
          if [[ "${{ inputs.specific_environment }}" != "" ]]; then
            if echo "$ENVIRONMENTS" | grep -q "${{ inputs.specific_environment }}"; then
              ENVIRONMENTS="${{ inputs.specific_environment }}"
            else
              echo "::warning::Specified environment not found in $CONFIG_PATH"
              continue
            fi
          fi
          
          # Process each environment for this resource
          for ENV in $ENVIRONMENTS; do
            echo "Processing environment: $ENV for $RESOURCE_PATH"
            
            # Extract parameters as compact JSON (no newlines)
            PARAMS=$(echo "$CONFIG_CONTENT" | jq -c --arg env "$ENV" '.deployments[0].parameters[$env]')
            RUNNER=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].runners[$env]')
            GH_ENV=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].github_environments[$env]')
            AWS_REGION=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].aws_regions[$env]')
            AWS_ROLE_SECRET=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].aws_role_secrets[$env] // "AWS_ROLE_TO_ASSUME"')
            CFN_ROLE_SECRET=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].cfn_role_secrets[$env] // "CFN_ROLE_ARN"')
            IAM_ROLE_SECRET=$(echo "$CONFIG_CONTENT" | jq -r --arg env "$ENV" '.deployments[0].iam_execution_role_secrets[$env] // "IAM_EXECUTION_ROLE_ARN"')
            VARS_CONFIG=$(echo "$CONFIG_CONTENT" | jq -c --arg env "$ENV" '.deployments[0].github_vars[$env] // {}')
            
            # Skip if any required field is empty
            if [[ -z "$PARAMS" || "$PARAMS" == "null" || -z "$RUNNER" || "$RUNNER" == "null" || 
                  -z "$GH_ENV" || "$GH_ENV" == "null" || -z "$AWS_REGION" || "$AWS_REGION" == "null" ]]; then
              echo "::warning::Missing required configuration for $RESOURCE_PATH in $ENV environment"
              continue
            fi
            
            # Process secrets in parameters if enabled
            PROCESSED_PARAMS=$(process_secrets_in_json "$PARAMS")
            
            # Create matrix item (all on one line)
            MATRIX_ITEM="{\"application\":\"$APP\",\"resource\":\"$RESOURCE\",\"environment\":\"$ENV\",\"runner\":\"$RUNNER\",\"github_environment\":\"$GH_ENV\",\"aws_region\":\"$AWS_REGION\",\"aws_role_secret\":\"$AWS_ROLE_SECRET\",\"cfn_role_secret\":\"$CFN_ROLE_SECRET\",\"iam_role_secret\":\"$IAM_ROLE_SECRET\",\"github_vars\":$VARS_CONFIG,\"parameters\":$PROCESSED_PARAMS}"
            
            # Add to appropriate matrix based on environment
            if [[ "$ENV" == "dev" ]]; then
              DEV_MATRIX_ITEMS+=("$MATRIX_ITEM")
            elif [[ "$ENV" == "int" ]]; then
              INT_MATRIX_ITEMS+=("$MATRIX_ITEM")
            elif [[ "$ENV" == "prod" ]]; then
              PROD_MATRIX_ITEMS+=("$MATRIX_ITEM")
            fi
          done
        done
        
        # Construct environment-specific matrices
        if [ ${#DEV_MATRIX_ITEMS[@]} -eq 0 ]; then
          DEV_MATRIX_JSON="{\"include\":[]}"
        else
          DEV_MATRIX_JSON="{\"include\":[$(IFS=,; echo "${DEV_MATRIX_ITEMS[*]}")]}";
        fi
        
        if [ ${#INT_MATRIX_ITEMS[@]} -eq 0 ]; then
          INT_MATRIX_JSON="{\"include\":[]}"
        else
          INT_MATRIX_JSON="{\"include\":[$(IFS=,; echo "${INT_MATRIX_ITEMS[*]}")]}";
        fi
        
        if [ ${#PROD_MATRIX_ITEMS[@]} -eq 0 ]; then
          PROD_MATRIX_JSON="{\"include\":[]}"
        else
          PROD_MATRIX_JSON="{\"include\":[$(IFS=,; echo "${PROD_MATRIX_ITEMS[*]}")]}";
        fi
        
        # Verify JSON is valid
        echo "$DEV_MATRIX_JSON" | jq . > /dev/null 2>&1
        echo "$INT_MATRIX_JSON" | jq . > /dev/null 2>&1
        echo "$PROD_MATRIX_JSON" | jq . > /dev/null 2>&1
        
        # Write matrices to outputs
        echo "dev_matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$DEV_MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "int_matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$INT_MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "prod_matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$PROD_MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT