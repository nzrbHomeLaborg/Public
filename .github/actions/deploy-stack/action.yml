name: 'Deploy CloudFormation Stack'
description: 'Deploys a CloudFormation stack with the specified parameters'
inputs:
  environment:
    description: 'Environment to deploy to (dev, int, prod)'
    required: true
  stack-name:
    description: 'Name of the CloudFormation stack'
    required: true
  bucket-name:
    description: 'S3 bucket for CloudFormation template storage'
    required: true
  bucket-upload:
    description: 'Whether to upload templates to S3'
    required: false
    default: 'true'
  target-folder:
    description: 'Target folder in S3 bucket'
    required: false
    default: ''
  source-folder:
    description: 'Source folder containing templates'
    required: true
  template-name:
    description: 'Name of the main CloudFormation template'
    required: true
  filename-patterns:
    description: 'File patterns to upload to S3'
    required: false
    default: '**/*.yaml'
  cfnLintEnabled:
    description: 'Whether to run CloudFormation linting'
    required: false
    default: 'true'
  extraArgs:
    description: 'Extra arguments for CloudFormation commands'
    required: false
    default: ''
  parameter-file:
    description: 'Path to parameter file'
    required: false
    default: ''
  inline-parameters:
    description: 'Inline parameters as JSON string'
    required: false
    default: '{}'
  tags:
    description: 'Tags to apply to the CloudFormation stack'
    required: false
    default: ''
  aws-region:
    description: 'AWS region for deployment'
    required: true
  aws-role-to-assume:
    description: 'AWS role to assume for operations'
    required: false
    default: ''
  cfn-role-arn:
    description: 'CloudFormation execution role ARN'
    required: false
    default: ''
  iam-execution-role-arn:
    description: 'IAM execution role ARN'
    required: false
    default: ''
  github-token:
    description: 'GitHub token for creating releases'
    required: true
  create-release:
    description: 'Whether to create a GitHub release after deployment'
    required: false
    default: 'false'
  release-tag:
    description: 'Tag name for the release'
    required: false
  release-name:
    description: 'Name of the release'
    required: false
  release-notes:
    description: 'Additional notes to include in the release description'
    required: false
  draft-release:
    description: 'Whether the release should be a draft'
    required: false
    default: 'false'
  prerelease:
    description: 'Whether the release should be marked as a pre-release'
    required: false
    default: 'false'




runs:
  using: "composite"
  steps:
    - name: Deploy CloudFormation Stack
      shell: bash
      run: |
        echo "Deploying stack to ${{ inputs.environment }} environment:"
        echo "  - Stack name: ${{ inputs.stack-name }}"
        echo "  - AWS Region: ${{ inputs.aws-region }}"
        echo "  - Template: ${{ inputs.source-folder }}/${{ inputs.template-name }}"
        
        # Call the actual deployment action
        # Note: This will use the AWS credentials configured in the job that calls this action
        
        # In an actual implementation, this would execute a command similar to:
        # aws cloudformation deploy \
        #   --template-file ${{ inputs.source-folder }}/${{ inputs.template-name }} \
        #   --stack-name ${{ inputs.stack-name }} \
        #   --parameter-overrides ${{ inputs.parameter-file }} \
        #   --tags ${{ inputs.tags }} \
        #   --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND \
        #   --role-arn ${{ inputs.cfn-role-arn }}
        
        # For now, we'll use the existing composite action
        echo "Calling cat-digital-platform/CD-GitHub-Actions/aws-cfn-lint-upload-create-update-composite"
        
        # For demonstration, we'll just echo the command parameters
        echo "  - environment: ${{ inputs.environment }}"
        echo "  - stack-name: ${{ inputs.stack-name }}"
        echo "  - bucket-name: ${{ inputs.bucket-name }}"
        echo "  - upload-to-s3: ${{ inputs.bucket-upload }}"
        echo "  - target-folder: ${{ inputs.target-folder }}"
        echo "  - source-folder: ${{ inputs.source-folder }}"
        echo "  - template-name: ${{ inputs.template-name }}"
        echo "  - filename-patterns: ${{ inputs.filename-patterns }}"
        echo "  - cfnLintEnabled: ${{ inputs.cfnLintEnabled }}"
        echo "  - extraArgs: ${{ inputs.extraArgs }}"
        echo "  - parameter-file: ${{ inputs.parameter-file }}"
        echo "  - inline-parameters: ${{ inputs.inline-parameters }}"
        echo "  - tags: ${{ inputs.tags }}"
        echo "  - aws-region: ${{ inputs.aws-region }}"
        echo "  - aws-role-to-assume: ${{ inputs.aws-role-to-assume }}"
        echo "  - cfn-role-arn: ${{ inputs.cfn-role-arn }}"
        echo "  - iam-execution-role-arn: ${{ inputs.iam-execution-role-arn }}"
        ls
        cat ${{ inputs.parameter-file }}

    - name: Process Parameters
      id: process-params
      shell: bash
      run: |
        # Create temp directory
        TEMP_DIR="${{ runner.temp }}/cfn-params"
        mkdir -p "$TEMP_DIR"
        
        # Process parameter file
        PARAM_FILE="${{ matrix.parameters.parameter-file }}"
        PROCESSED_PARAM_FILE=""
        
        if [[ -n "$PARAM_FILE" && "$PARAM_FILE" != "null" ]]; then
          echo "Processing parameter file: $PARAM_FILE"
          if [[ -f "$PARAM_FILE" ]]; then
            CONTENT=$(cat "$PARAM_FILE")
            
            # Check for secrets pattern more safely
            if echo "$CONTENT" | grep -q "secrets\."; then
              echo "Secrets found in parameter file, processing them"
              
              # Create processed file
              PROCESSED_PARAM_FILE="$TEMP_DIR/processed-params.json"
              cp "$PARAM_FILE" "$PROCESSED_PARAM_FILE"
              
              # Get list of all secrets
              ALL_SECRETS=$(env | grep "^SECRETS_" | cut -d= -f1)
              
              # Replace each secret
              for SECRET_VAR in $ALL_SECRETS; do
                # Get the actual secret name without the SECRETS_ prefix
                SECRET_NAME=${SECRET_VAR#SECRETS_}
                
                # Get the secret value
                SECRET_VALUE=${!SECRET_VAR}
                
                # Construct the pattern to look for
                PATTERN="\\\${{[[:space:]]*secrets\\.$SECRET_NAME[[:space:]]*}}"
                
                # Replace in the file
                sed -i "s|$PATTERN|$SECRET_VALUE|g" "$PROCESSED_PARAM_FILE"
              done
              
              echo "Parameter file processed: $PROCESSED_PARAM_FILE"
            else
              echo "No secrets found in parameter file, using original file"
              PROCESSED_PARAM_FILE="$PARAM_FILE"
            fi
          else
            echo "WARNING: Parameter file not found: $PARAM_FILE"
            PROCESSED_PARAM_FILE="$PARAM_FILE"
          fi
        fi
        
        # Process inline parameters
        INLINE_PARAMS='${{ toJSON(matrix.parameters.inline-parameters) }}'
        PROCESSED_INLINE_PARAMS="$INLINE_PARAMS"
        
        if [[ "$INLINE_PARAMS" != "null" && -n "$INLINE_PARAMS" ]]; then
          echo "Processing inline parameters"
          
          # Check for secrets pattern more safely
          if echo "$INLINE_PARAMS" | grep -q "secrets\."; then
            echo "Secrets found in inline parameters, processing them"
            
            # Get list of all secrets
            ALL_SECRETS=$(env | grep "^SECRETS_" | cut -d= -f1)
            
            # Replace each secret
            for SECRET_VAR in $ALL_SECRETS; do
              # Get the actual secret name without the SECRETS_ prefix
              SECRET_NAME=${SECRET_VAR#SECRETS_}
              
              # Get the secret value
              SECRET_VALUE=${!SECRET_VAR}
              
              # Construct the pattern to look for
              PATTERN="\\\${{[[:space:]]*secrets\\.$SECRET_NAME[[:space:]]*}}"
              
              # Replace in the inline params
              PROCESSED_INLINE_PARAMS=$(echo "$PROCESSED_INLINE_PARAMS" | sed "s|$PATTERN|$SECRET_VALUE|g")
            done
            
            echo "Inline parameters processed"
          else
            echo "No secrets found in inline parameters"
          fi
        fi
        
        # Set outputs
        echo "param_file=$PROCESSED_PARAM_FILE" >> $GITHUB_OUTPUT
        echo "inline_params=$PROCESSED_INLINE_PARAMS" >> $GITHUB_OUTPUT



    - name: Create GitHub Release
      if: ${{ inputs.create-release == 'true' }}
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ github.token }}
      with:
        tag_name: ${{ inputs.release-tag || github.sha }}
        release_name: ${{ inputs.release-name || 'CloudFormation Templates Release' }}
        body: |
          CloudFormation templates have been validated, uploaded to S3, and deployed successfully.
          
          Stack name: ${{ inputs.stack-name }}
          Region: ${{ inputs.aws-region }}
          ${{ inputs.release-notes }}
        draft: ${{ inputs.draft-release == 'true' }}
        prerelease: ${{ inputs.prerelease == 'true' }}


        # - name: Create GitHub Release
    #   if: ${{ inputs.create-release == 'true' }}
    #   uses: softprops/action-gh-release@v1
    #   with:
    #     tag_name: ${{ inputs.release-tag || format('v{0}', github.run_number) }}
    #     name: ${{ inputs.release-name || 'CloudFormation Templates Release' }}
    #     body: |
    #       CloudFormation templates have been validated, uploaded to S3, and deployed successfully.
          
    #       Stack name: ${{ inputs.stack-name }}
    #       Region: ${{ inputs.aws-region }}
    #       ${{ inputs.release-notes }}
    #     draft: ${{ inputs.draft-release == 'true' }}
    #     prerelease: ${{ inputs.prerelease == 'true' }}
    #     files: ${{ inputs.source-folder }}/${{ inputs.template-name }}
    #   env:
    #     GITHUB_TOKEN: ${{ github.token }}

    - name: Upload templates to release
      if: ${{ inputs.create-release == 'true' }}
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ github.token }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ${{ inputs.source-folder }}/${{ inputs.template-name }}
        asset_name: ${{ inputs.template-name }}
        asset_content_type: application/zip    
